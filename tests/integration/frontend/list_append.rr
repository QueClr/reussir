// RUN: %reussir-compiler %s -t mlir -o %t.mlir
// RUN: %FileCheck %s --check-prefix=CHECK-MLIR < %t.mlir
enum List<T> {
    Nil,
    Cons(T, List<T>)
}

// Append two lists: first list is consumed, second is passed through.
// Token reuse should kick in: when the head cons cell has refcount 1,
// it can be reused directly (just overwrite the tail pointer).
fn append(a : List<i32>, b : List<i32>) -> List<i32> {
    match a {
        List::Nil => b,
        List::Cons(x, xs) => List::Cons{x, append(xs, b)}
    }
}

// --- MLIR ownership checks ---
// append(%0=a, %1=b): consuming first list, passing through second
// CHECK-MLIR-LABEL: reussir.func @"_RC6append"(%0 :
// CHECK-MLIR:       reussir.rc.borrow (%0 :
// CHECK-MLIR:       reussir.record.dispatch
// Nil: dec a, yield b (ownership of b transfers to caller)
// CHECK-MLIR:       [0] ->
// CHECK-MLIR:       reussir.rc.dec (%0 :
// CHECK-MLIR:       reussir.scf.yield %1 :
// Cons(x, xs): load xs, inc xs, load x, dec a, build Cons{x, append(xs, b)}
// CHECK-MLIR:       [1] ->
// CHECK-MLIR:       reussir.ref.project
// CHECK-MLIR:       reussir.ref.load
// CHECK-MLIR:       reussir.rc.inc
// CHECK-MLIR:       reussir.ref.project
// CHECK-MLIR:       reussir.ref.load
// CHECK-MLIR:       reussir.rc.dec (%0 :
// CHECK-MLIR:       reussir.call @"_RC6append"
// CHECK-MLIR:       reussir.record.compound
// CHECK-MLIR:       reussir.record.variant
// CHECK-MLIR:       reussir.rc.create
